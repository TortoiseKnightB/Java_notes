# 多线程

### 方式一 继承 Thread 类

1. 创建一个继承于 **Thread** 类的子类
2. 子类中重写 Thread 类中的 `run()` 方法
3. 创建 Thread 子类对象，即线程对象
4. 调用线程对象的 `start()` 方法，启动线程

```java
class HelloThread extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() + ":" + Thread.currentThread().getPriority() + ":" + i);
        }
    }

    public HelloThread(String name) {
        super(name);
    }
}


public class ThreadMethodTest {
    public static void main(String[] args) {
        HelloThread h1 = new HelloThread("Thread：1");
        h1.start();
        
        HelloThread h2 = new HelloThread("Thread：2");
        h2.start();
    }
}  	
```

### Thread 类构造器

- `Thread()`: 创建新的 Thread 对象
- `Thread(String threadname)`: 创建线程并指定线程实例名
- `Thread(Runnable target)`: 指定创建线程的目标对象，它实现了 **Runnable** 接口中的 `run()` 方法
- `Thread(Runnable target, String name)`: 创建新的 Thread 对象

#### 常用方法

- `start()`: 启动当前线程，调用当前线程的 `run()`
- `run()`:  通常需要重写 Thread 类中的此方法，将创建的线程要执行的操作声明在此方法中
- `currentThread()`: 静态方法，返回执行当前代码的线程
- `getName()`: 获取当前线程的名字
- `setName()`: 设置当前线程的名字
- `yield()`: 释放当前cpu的执行权
- `join()`: 在线程 a 中调用线程 b 的 `join()`,此时线程 a 就进入阻塞状态，直到线程 b **完全**执行完以后，线程 a 才结束阻塞状态
- `sleep(long millitime)`: 让当前线程""睡眠"指定的 millitime 毫秒。在指定的 millitime 毫秒时间内，当前线程是阻塞状态
- `isAlive()`: 判断当前线程是否存活

#### 注意

- 想要启动多线程，必须调用 `start()` 方法。如果自己手动调用 `run()` 方法，那么就只是普通方法，没有启动多线程模式
- `run()` 方法由 JVM 调用，什么时候调用，执行的过程控制都由操作系统的 CPU 调度决定
- 一个线程对象只能调用一次 `start()` 方法启动，如果重复调用了，则将抛出异常 `IllegalThreadStateException`
- 高优先级的线程要抢占低优先级线程 cpu 的执行权。但是只是从**概率**上讲，高优先级的线程高概率的情况下被执行。并不意味着只有当高优先级的线程执行完以后，低优先级的线程才执行

------

### 方式二:实现Runnable接口

- Runnable 接口的方式没有类的单继承性的局限性
- `public class Thread implements Runnable`，**Thread** 类其实就是实现了 **Runnable** 接口

1. 创建一个实现了 Runnable 接口的类
2. 实现类去实现 Runnable 中的抽象方法：`run()`
3. 创建实现类的对象
4. 将此对象作为参数传递到 Thread 类的构造器中，创建 Thread 类的对象
5. 通过 Thread 类的对象调用 `start()`

```java
class MThread implements Runnable{
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + ":" + i);
    }
}


public class ThreadTest1 {
    public static void main(String[] args) {
        MThread mThread = new MThread();
      
        Thread t1 = new Thread(mThread);
        t1.setName("线程1");
        t1.start();

        Thread t2 = new Thread(mThread);
        t2.setName("线程2");
        t2.start();
    }
}
```








<p align="center">
        <img src="https://raw.githubusercontent.com/TortoiseKnightB/Java_notes/main/images/%E9%9B%86%E5%90%88/01.png" width="500"/>
</p>