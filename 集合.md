# 集合

### Collection接口继承树

<p align="center">
        <img src="https://raw.githubusercontent.com/TortoiseKnightB/Java_notes/main/images/%E9%9B%86%E5%90%88/01.png" width="500"/>
</p>

```
.
└── Collection接口：单列集合，用来存储单个的对象
    │
    ├── List接口：存储有序的、可重复的数据
    │   │ 
    │   ├── ArrayList：主要实现类，底层使用Object[] elementData存储；线程不安全的，效率高
    │   ├── LinkedList：底层使用双向链表存储；适用于频繁的插入、删除操作
    │ 	└── Vector：底层使用Object[] elementData存储；线程安全的，效率低；现在已经不使用
    │
    └── Set接口：存储无序的、不可重复的数据   
        │
	├── HashSet：主要实现类，线程不安全的；可以存储null值
	│   │ 
        │   └── LinkedHashSet：HashSet的子类；可以按照添加的顺序遍历内部数据，适用于频繁的遍历操作
        │
        └── TreeSet：可以按照添加对象的指定属性，进行排序。
 		  	
```

------

### 迭代器 Iterator

```java
	Collection coll = new ArrayList();
        coll.add(123);
	// 要求 Person 所在类要重写equals()
        coll.add(new User("Ben",22));
        coll.add(new String("Hello"));
        coll.add(true);

        Iterator iterator = coll.iterator();

	while(iterator.hasNext()){
            //next():①指针下移 ②将下移以后集合位置上的元素返回
            System.out.println(iterator.next());
        }

	// 删除集合中"hello"
        Iterator iterator = coll.iterator();
        while (iterator.hasNext()){
            Object obj = iterator.next();
            if("hello".equals(obj)){
                iterator.remove();
            }
        }
```

- 注意：向Collection接口的实现类的对象中添加数据obj时，要求obj所在类要重写equals().

<p align="center">
        <img src="https://raw.githubusercontent.com/TortoiseKnightB/Java_notes/main/images/%E9%9B%86%E5%90%88/02.png" width="500"/>
</p>

------

### List 接口

- **ArrayList**

&ensp;&ensp;&ensp;&ensp;`ArrayList list = new ArrayList();` 底层 `Object[] elementData` 初始化为{}

<p align="center">
        <img src="https://raw.githubusercontent.com/TortoiseKnightB/Java_notes/main/images/%E9%9B%86%E5%90%88/03.png" width="500"/>
</p>

<p align="center">
        <img src="https://raw.githubusercontent.com/TortoiseKnightB/Java_notes/main/images/%E9%9B%86%E5%90%88/04.png" width="500"/>
</p>

&ensp;&ensp;&ensp;&ensp;`list.add(123);` 第一次调用 `add()` 时，底层才创建了长度10的数组，并将数据123添加到 `elementData[0]`

<p align="center">
        <img src="https://raw.githubusercontent.com/TortoiseKnightB/Java_notes/main/images/%E9%9B%86%E5%90%88/05.png" width="500"/>
</p>

------


- **LinkedList**

&ensp;&ensp;&ensp;&ensp;`LinkedList list = new LinkedList();` 内部声明了 Node 类型的 first 和 last 属性，默认值为 null

<p align="center">
        <img src="https://raw.githubusercontent.com/TortoiseKnightB/Java_notes/main/images/%E9%9B%86%E5%90%88/06.png" width="500"/>
</p>

&ensp;&ensp;&ensp;&ensp;`list.add(123);` 将123封装到 Node 中，创建了 Node 对象

<p align="center">
        <img src="https://raw.githubusercontent.com/TortoiseKnightB/Java_notes/main/images/%E9%9B%86%E5%90%88/07.png" width="500"/>
</p>

<p align="center">
        <img src="https://raw.githubusercontent.com/TortoiseKnightB/Java_notes/main/images/%E9%9B%86%E5%90%88/08.png" width="500"/>
</p>

------

- **List 常用方法**

&ensp;&ensp;&ensp;&ensp;`void add(int index, Object ele)`：在 index 位置插入 ele 元素

&ensp;&ensp;&ensp;&ensp;`boolean addAll(int index, Collection eles)`：在 index 位置插入 eles 中的所有元素

&ensp;&ensp;&ensp;&ensp;`Object get(int index)`：获取指定 index 位置的元素

&ensp;&ensp;&ensp;&ensp;`int indexOf(Object obj)`：返回 obj 在集合中首次出现的位置

&ensp;&ensp;&ensp;&ensp;`int lastIndexOf(Object obj)`：返回 obj 在当前集合中最后出现的位置

&ensp;&ensp;&ensp;&ensp;`Object remove(int index)` / `remove(Object obj)`：移除指定 index 位置的元素 / 移除首个指定元素，并返回此元素（注意 int 型参数会冲突）

&ensp;&ensp;&ensp;&ensp;`Object set(int index, Object ele)`：设置指定 index 位置的元素为ele

&ensp;&ensp;&ensp;&ensp;`List subList(int fromIndex, int toIndex)`：返回从 fromIndex 到 toIndex 位置的子集合

------

### Set 接口

- **HashSet**
	- **无序性**：存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的
	- **不可重复性**：保证添加的元素按照 `equals()` 判断时，不能返回 true. 相同的元素只能添加一个
	- 向Set (主要指：HashSet、LinkedHashSet) 中添加的数据，其所在的类一定要重写 `hashCode()` 和 `equals()` 
- **向 HashSet 中添加元素 a**
1. 首先调用元素 a 所在类的 `hashCode()` 方法，计算元素 a 的哈希值。接着通过某种算法计算出此哈希值在 HashSet 底层数组中的存放位置（即为：索引位置），判断数组此位置上是否已经有元素：

&ensp;&ensp;&ensp;&ensp;如果此位置上没有其他元素，则元素 a 添加成功。 **------------>情况1**

2. 如果此位置上有其他元素 b (或以链表形式存在的多个元素），则比较元素 a 与元素 b 的 hash 值：

&ensp;&ensp;&ensp;&ensp;如果 hash 值不相同，则元素 a 添加成功。**-------------------->情况2**

3. 如果 hash 值相同，进而需要调用元素a所在类的 `equals()` 方法：

&ensp;&ensp;&ensp;&ensp;`equals()` 返回 true，元素 a 添加失败

&ensp;&ensp;&ensp;&ensp;`equals()` 返回 false，则元素 a 添加成功。**------------------>情况3**

- 对于添加成功的情况2和情况3而言：元素a 与已经存在指定索引位置上数据以链表的方式存储。

&ensp;&ensp;&ensp;&ensp;jdk 7 ：元素a放到数组中，指向原来的元素。

&ensp;&ensp;&ensp;&ensp;jdk 8 ：原来的元素在数组中，指向元素a

------

- **LinkedHashSet**
  - **底层结构**：与 **HashSet** 不同，**LinkedHashSet** 存储的数据会以链表的形式，拥有头指针与尾指针，记录数据添加的顺序。对于频繁的遍历操作，其效率更高

<p align="center">
        <img src="https://raw.githubusercontent.com/TortoiseKnightB/Java_notes/main/images/集合/09.jpg" width="600"/>
</p>

------

### TreeSet

- 向 TreeSet 中添加的数据，要求是**相同类**的对象
- 底层采用**红黑树**的存储结构
- **自然排序** `TreeSet set = new TreeSet();` ，其类实现 `Comparable` 接口，重写 `compareTo()` 方法
- **定制排序** `TreeSet set = new TreeSet(comparator );`，创建 `Comparator` 对象，并重写其 `compare` 方法，作为参数传入

------



