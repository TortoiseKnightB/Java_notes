# 集合

### Collection接口继承树

<p align="center">
        <img src="https://raw.githubusercontent.com/TortoiseKnightB/Java_notes/main/images/%E9%9B%86%E5%90%88/01.png" width="500"/>
</p>

```
.
└── Collection接口：单列集合，用来存储单个的对象
    │
    ├── List接口：存储有序的、可重复的数据
    │   │ 
    │   ├── ArrayList：主要实现类，底层使用Object[] elementData存储；线程不安全的，效率高
    │   ├── LinkedList：底层使用双向链表存储；适用于频繁的插入、删除操作
    │ 	└── Vector：底层使用Object[] elementData存储；线程安全的，效率低；现在已经不使用
    │
    └── Set接口：存储无序的、不可重复的数据   
        │
	├── HashSet：主要实现类，线程不安全的；可以存储null值
	│   │ 
        │   └── LinkedHashSet：HashSet的子类；可以按照添加的顺序遍历内部数据，适用于频繁的遍历操作
        │
        └── TreeSet：可以按照添加对象的指定属性，进行排序。
 		  	
```

------

### 迭代器 Iterator

```java
	Collection coll = new ArrayList();
        coll.add(123);
	// 要求 Person 所在类要重写equals()
        coll.add(new User("Ben",22));
        coll.add(new String("Hello"));
        coll.add(true);

        Iterator iterator = coll.iterator();

	while(iterator.hasNext()){
            //next():①指针下移 ②将下移以后集合位置上的元素返回
            System.out.println(iterator.next());
        }

	// 删除集合中"hello"
        Iterator iterator = coll.iterator();
        while (iterator.hasNext()){
            Object obj = iterator.next();
            if("hello".equals(obj)){
                iterator.remove();
            }
        }
```

- 注意：向Collection接口的实现类的对象中添加数据obj时，要求obj所在类要重写equals().

<p align="center">
        <img src="https://raw.githubusercontent.com/TortoiseKnightB/Java_notes/main/images/%E9%9B%86%E5%90%88/02.png" width="500"/>
</p>

------

### List 接口

- **ArrayList**

&ensp;&ensp;&ensp;&ensp;`ArrayList list = new ArrayList();` 底层 `Object[] elementData` 初始化为{}

<p align="center">
        <img src="https://raw.githubusercontent.com/TortoiseKnightB/Java_notes/main/images/%E9%9B%86%E5%90%88/03.png" width="500"/>
</p>

<p align="center">
        <img src="https://raw.githubusercontent.com/TortoiseKnightB/Java_notes/main/images/%E9%9B%86%E5%90%88/04.png" width="500"/>
</p>

&ensp;&ensp;&ensp;&ensp;`list.add(123);` 第一次调用 `add()` 时，底层才创建了长度10的数组，并将数据123添加到 `elementData[0]`

<p align="center">
        <img src="https://raw.githubusercontent.com/TortoiseKnightB/Java_notes/main/images/%E9%9B%86%E5%90%88/05.png" width="500"/>
</p>

------


- **LinkedList**

&ensp;&ensp;&ensp;&ensp;`LinkedList list = new LinkedList();` 内部声明了 Node 类型的 first 和 last 属性，默认值为 null

<p align="center">
        <img src="https://raw.githubusercontent.com/TortoiseKnightB/Java_notes/main/images/%E9%9B%86%E5%90%88/06.png" width="500"/>
</p>

&ensp;&ensp;&ensp;&ensp;`list.add(123);` 将123封装到 Node 中，创建了 Node 对象

<p align="center">
        <img src="https://raw.githubusercontent.com/TortoiseKnightB/Java_notes/main/images/%E9%9B%86%E5%90%88/07.png" width="500"/>
</p>

<p align="center">
        <img src="https://raw.githubusercontent.com/TortoiseKnightB/Java_notes/main/images/%E9%9B%86%E5%90%88/08.png" width="500"/>
</p>

------

- **List 常用方法**

&ensp;&ensp;&ensp;&ensp;`void add(int index, Object ele)`：在 index 位置插入 ele 元素

&ensp;&ensp;&ensp;&ensp;`boolean addAll(int index, Collection eles)`：在 index 位置插入 eles 中的所有元素

&ensp;&ensp;&ensp;&ensp;`Object get(int index)`：获取指定 index 位置的元素

&ensp;&ensp;&ensp;&ensp;`int indexOf(Object obj)`：返回 obj 在集合中首次出现的位置

&ensp;&ensp;&ensp;&ensp;`int lastIndexOf(Object obj)`：返回 obj 在当前集合中最后出现的位置

&ensp;&ensp;&ensp;&ensp;`Object remove(int index)` / `remove(Object obj)`：移除指定 index 位置的元素 / 移除首个指定元素，并返回此元素（注意 int 型参数会冲突）

&ensp;&ensp;&ensp;&ensp;`Object set(int index, Object ele)`：设置指定 index 位置的元素为ele

&ensp;&ensp;&ensp;&ensp;`List subList(int fromIndex, int toIndex)`：返回从 fromIndex 到 toIndex 位置的子集合

&ensp;&ensp;&ensp;&ensp;`boolean isEmpty()`：如果没有元素，返回 true

&ensp;&ensp;&ensp;&ensp;`int size()`：返回元素个数

------

### Set 接口

- **HashSet**
	- **无序性**：存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的
	- **不可重复性**：保证添加的元素按照 `equals()` 判断时，不能返回 true. 相同的元素只能添加一个
	- 向Set (主要指：HashSet、LinkedHashSet) 中添加的数据，其所在的类一定要重写 `hashCode()` 和 `equals()` 
- **向 HashSet 中添加元素 a**
1. 首先调用元素 a 所在类的 `hashCode()` 方法，计算元素 a 的哈希值。接着通过某种算法计算出此哈希值在 HashSet 底层数组中的存放位置（即为：索引位置），判断数组此位置上是否已经有元素：

&ensp;&ensp;&ensp;&ensp;如果此位置上没有其他元素，则元素 a 添加成功。 **------------>情况1**

2. 如果此位置上有其他元素 b (或以链表形式存在的多个元素），则比较元素 a 与元素 b 的 hash 值：

&ensp;&ensp;&ensp;&ensp;如果 hash 值不相同，则元素 a 添加成功。**-------------------->情况2**

3. 如果 hash 值相同，进而需要调用元素a所在类的 `equals()` 方法：

&ensp;&ensp;&ensp;&ensp;`equals()` 返回 true，元素 a 添加失败

&ensp;&ensp;&ensp;&ensp;`equals()` 返回 false，则元素 a 添加成功。**------------------>情况3**

- 对于添加成功的情况2和情况3而言：元素a 与已经存在指定索引位置上数据以链表的方式存储。

&ensp;&ensp;&ensp;&ensp;jdk 7 ：元素a放到数组中，指向原来的元素。

&ensp;&ensp;&ensp;&ensp;jdk 8 ：原来的元素在数组中，指向元素a

------

- **LinkedHashSet**
  - **底层结构**：与 **HashSet** 不同，**LinkedHashSet** 存储的数据会以链表的形式，拥有头指针与尾指针，记录数据添加的顺序。对于频繁的遍历操作，其效率更高

<p align="center">
        <img src="https://raw.githubusercontent.com/TortoiseKnightB/Java_notes/main/images/集合/09.jpg" width="600"/>
</p>

------

### TreeSet

- 向 TreeSet 中添加的数据，要求是**相同类**的对象
- 底层采用**红黑树**的存储结构
- **自然排序** `TreeSet set = new TreeSet();` ，其类实现 `Comparable` 接口，重写 `compareTo()` 方法
- **定制排序** `TreeSet set = new TreeSet(comparator );`，创建 `Comparator` 对象，并重写其 `compare` 方法，作为参数传入

------

### Set 与 List 的转换

- **List => HashSet**

```java
	HashSet set = new HashSet();
        set.addAll(list);
```

- **HashSet => List**

```java
	List list = new ArrayList(set);
```

------

### HashSet 内存解析

```java
        HashSet set = new HashSet();
        Person p1 = new Person(1001,"AA");		// 此处 Person 已重写 hashCode() 和 equals()、toString()
        Person p2 = new Person(1002,"BB");

        set.add(p1);
        set.add(p2);
        System.out.println(set);	// [Person{id=1002, name='BB'}, Person{id=1001, name='AA'}]

        p1.name = "CC";
        set.remove(p1);
        System.out.println(set);	// [Person{id=1002, name='BB'}, Person{id=1001, name='CC'}]
        set.add(new Person(1001,"CC"));
        System.out.println(set);	// [Person{id=1002, name='BB'}, Person{id=1001, name='CC'}, Person{id=1001, name='CC'}]
        set.add(new Person(1001,"AA"));
        System.out.println(set);	// [Person{id=1002, name='BB'}, Person{id=1001, name='CC'}, Person{id=1001, name='CC'}, Person{id=1001, name='AA'}]

```

- **HashSet** 存储数据时先根据 `hashCode()` 计算出的哈希值进行判断，若哈希值相同，再用 `equals()` 判断数据内容是否相同
- `p1.name = "CC";` 语句改变了 p1 的属性， `hashCode()` 计算出的哈希值也发生相应的改变（p1 的存储位置没有发生改变）。于是当执行 `set.remove(p1);` 语句时，根据 `hashCode()` 的结果找不到 p1 的存储位置，p1 也就没有被移除
- 当执行 `set.add(new Person(1001,"CC"));` 时，根据 `hashCode()` 计算出的哈希值查找对应的存储位置，发现位置为空，于是存储数据成功。这时 set 中存在两个重复的 `new Person(1001,"CC"))`，一个由 `new Person(1001,"AA")` 改变得来，一个新存储的
- 当执行 `set.add(new Person(1001,"AA"));` 时，根据 `hashCode()` 计算出的哈希值查找对应的存储位置，发现位置已有数据，于是用 `equals()` 进一步比对，发现数据内容不同，存储成功

------

### Map

```
.
└── Map：双列数据，存储 key-value 对  
    │
    ├── HashMap：主要实现类；线程不安全的，效率高；可以存储 null 的 key 和 value
    │   │ 
    │   ├── 
    │   ├── 
    │ 	└── 
    │
    ├── TreeMap：保证按照添加的 key-value 对进行排序，实现排序遍历。此时考虑 key 的自然排序或定制排序，底层使用红黑树
    │   │ 
    │   ├── 
    │   ├── 
    │ 	└── 
    │
    └── Hashtable：古老的实现类；线程安全的，效率低；不能存储 null 的 key 和 value
 		  	
```

- Map 中的 **key**：无序的、不可重复的，使用 **Set** 存储所有的 key  ---> key 所在的类要重写 `equals()` 和 `hashCode() ` 
- Map 中的 **value**：无序的、可重复的，使用 **Collection** 存储所有的 value ---> value 所在的类要重写 `equals()`
- 一个键值对：**key-value** 构成了一个 **Entry** 对象
- Map 中的 **Entry**：无序的、不可重复的，使用 **Set** 存储所有的 Entry